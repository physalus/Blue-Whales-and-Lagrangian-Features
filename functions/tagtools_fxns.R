#' Estimate the vertical velocity 
#' 
#' This function is used to estimate the vertical velocity by differentiating a depth or altitude time series. A low-pass filter reduces the sensor noise that is amplified by the differentiation.
#' 
#' Possible input combinations: depth_rate(p) if p is a list, depth_rate(p,fc = fc) if p is a list, depth_rate(p,fs) if p is a vector, depth_rate(p,fs,fc) if p is a vector.
#' @param p A depth or altitude time series or a list of depth or altitude (e.g., from readtag.R). p can have any units and is in the form of a vector
#' @param fs is the sampling rate of p in Hz.
#' @param fc (optional) A smoothing filter cut-off frequency in Hz. If fc is not given, a default value is used of 0.2 Hz (5 second time constant).
#' @return The vertical velocity with the same sampling rate as p. v has the same dimensions as p. The unit of v depends on the unit of p. If p is in meters, v is in meters/second
#' @note The low-pass filter is a symmetric FIR with length 4fs/fc. The group delay of the filters is removed.
#' @examples
#' BW <- beaked_whale
#' v <- depth_rate(p = BW$P$data, fs = BW$P$sampling_rate, fc = .8)
#' depthrate <- list(v = v)
#' plott(depthrate, BW$P$sampling_rate)
#'  @export

depth_rate <- function(p, fs, fc) {
  if (missing(p)) {
    stop("input for p is required")
  }
  if (is.list(p)) {
    if (nargs() > 1) {
      fc <- fs 
    } else {
      fc <- c()
    }
    fs <- p$fs
    p <- p$data
  } else {
    if(missing(fc)){
      fc <- 0.2
    }
  }
  nf <- round(4 * fs / fc)
  #use central differences to avoid a half sample delay
  x1 <- p[2] - p[1]
  x2 <- (p[3:length(p)] - p[1:(length(p) - 2)]) / 2
  x3 <- p[length(p)] - p[length(p) - 1]
  X <- c(x1, x2, x3)
  diffp <- X * fs
  #low pass filter to reduce sensor noise
  v <- fir_nodelay(diffp, nf, fc / (fs / 2))$y
  return(v)
}


#' Delay-free filtering 
#' 
#' This function is used to gather a delay-free filtering using a linear-phase (symmetric) FIR filter followed by group delay correction. Delay-free filtering is needed when the relative timing between signals is important e.g., when integrating signals that have been sampled at different rates.
#' @param x The signal to be filtered. It can be multi-channel with a signal in each column, e.g., an acceleration matrix. The number of samples (i.e., the number of rows in x) must be larger than the filter length, n.
#' @param n The length of symmetric FIR filter to use in units of input samples (i.e., samples of x). The length should be at least 4/fc. A longer filter gives a steeper cut-off.
#' @param fc The filter cut-off frequency relative to sampling_rate/2=1. If a single number is given, the filter is a low-pass or high-pass. If fc is a vector with two numbers, the filter is a bandpass filter with lower and upper cut-off frequencies given by fc(1) and fc(2). For a bandpass filter, n should be at least 4/fc(1) or 4/diff(fc) whichever is larger.
#' @param qual An optional qualifier determining if the filter is: "low" for low-pass (the default value if fc has a single number), or "high" for high-pass. Default is "low".
#' @export
#' @return A list with elements:
#' \itemize{
#'  \item{y} The filtered signal with the same size as x.
#'  \item{h} The vector of filter coefficients used by fir_nodelay (a vector). 
#' }
#' @note The filter is generated by a call to fir1: h <- fir1(n, fc, qual).
#' @note h is always an odd length filter even if n is even. This is needed to ensure that the filter is both symmetric and has a group delay which is an integer number of samples. 
#' @note The filter has a support of n samples, i.e., it uses n samples from x to compute each sample in y. 
#' @note The input samples used are those from n/2 samples before to n/2 samples after the sample number being computed. This means that samples at the start and end of the output vector y need input samples before the start of x and after the end of x. These are faked by reversing the first n/2 samples of x and concatenating them to the start of x. The same trick is used at the end of x. As a result, the first and last n/2 samples in y are untrustworthy. This initial condition problem is true for any filter but the FIR filter used here makes it easy to identify precisely which samples are unreliable.
#' @examples \dontrun{
#'          #Make a waveform with two harmonics - one at 1/20 and another at 1/4 of the sampling rate.
#'          x <- sin(t(2 * pi * 0.05 * (1:100)) +
#'                 t(cos(2 * pi * 0.25 * (1:100))))
#'          Y <- fir_nodelay(x=x, n=30, fc=0.2, qual='low')
#'          plot(c(1:length(x)),x, type='l', col='grey42',
#'          xlab='index', ylab='input x and output y')
#'          lines(c(1:length(Y$y)),Y$y, lwd=2)
#'          #Returns: The input signal has the first and fifth harmonic. 
#'          #Applying the low-pass filter removes most of the fifth harmonic
#'          # so the output appears as a sinewave except for the first few 
#'          #samples which are affected by the filter startup transient.
#'          }
#' 

fir_nodelay <- function(x, n, fc, qual='low'){
  # input checking
  # ================================================================
  # make sure x is a column vector or matrix
  if (!(sum(class(x) %in% c('matrix', 'vector')))){
    x <- as.matrix(x)
  }
  if (is.vector(x)) x <- as.matrix(x, nrow=length(x))
  # in case of multi-channel data, make sure matrix rows are samples and columns are channels
  if (dim(x)[2] > dim(x)[1]) x <- t(x) 
  # make sure n is even to ensure an integer group delay
  n <- floor(n/2)*2
  
  
  # generate fir filter
  # ============================================================
  h <- signal::fir1(n=n,w=fc, type=qual)
  
  # append fake samples to start and end of x to absorb filter delay
  # (output from these will be removed before returning result to user)
  nofsampling_rate <- floor(n/2)
  top_pad <- matrix(x[nofsampling_rate:2,], ncol=ncol(x))
  bot_pad <- matrix(x[(nrow(x)-1):(nrow(x)-nofsampling_rate),], ncol=ncol(x))
  x_pad <- rbind(top_pad, x, bot_pad)
  
  # filter the signal
  # ============================================================
  # apply filter to padded signal
  y <- matrix(0, nrow=nrow(x_pad), ncol=ncol(x_pad))
  for (c in 1:ncol(x_pad)){
    y[,c] <- as.matrix(signal::filter(x=x_pad[,c], filt=h), 
                       nrow=nrow(x_pad))
  }
  # account for filter ofsampling_rateet (remove padding)
  y = y[n-1+(1:nrow(x)),]
  
  return(list(y=y, h=h))
}




